                                ~~~~~~~~~~~~~~~~~~~~~~~~~
                                ~~~~~~INSTALLATION~~~~~~~
                                ~~~~~~~~~~~~~~~~~~~~~~~~~

1. You can get the R interface of package 'volesti' from
"https://github.com/TolisChal/volume_approximation/tree/volesti_tutorial".

  a. Download the zip file from the github and extract it locally.

  b. An alternative is to use git. In command line run:

```
$ git clone https://github.com/TolisChal/volume_approximation.git
$ cd volume_approximation
$ git checkout volesti_tutorial
```

                          ------------------------------------------------------

2. To install package open with Rstudio the file 'volesti.Rproj' in folder /R-proj. Then in Rstudio run:

```
> install.packages("devtools")
> install.packages("Rcpp")
> install.packages("RcppEigen")
> install.packages("BH")
```

  a. Then from `Build` in menu bar click `build source Package` and when build is done click `Install and Restart`.

  b. An alternative is to use Rstudio command line. Run:

```
> Rcpp::compialeAtributes()
> devtools::build()
> devtools::install()

3. You will also need the package `Peacock.test` for the exercises, so run in Rstudio command line:

```
> install.packages("Peacock.test")
```


                                ~~~~~~~~~~~~~~~~~~~~~~~~~
                                ~~~~~~~HOW TO USE~~~~~~~~
                                ~~~~~~~~~~~~~~~~~~~~~~~~~
1. Generate Polytopes

You can use `volesti` to generate some well known and studied polytopes, such as hypercubes, simplices,
cross polytopes, skinny hypercubes, product of two simplices or random zonotopes. For example to generate
a 3d-dimensional cube run:

```
> PolyList = GenCube(3, 'H')
```

The first argument is the dimension and the second declares the representation of the polytope. The string
'H' is for the H-representation, when the polytope is defined by a set of linear inequalities, and 'V' is
for the V-representation, when the polytope is defined by a set of vertices.

The output, e.g. `PolyList`, is a R list that containes two elements: The PolyList$A is the \{ mxd \}
matrix A and PolyList$b is a \{ m \} dimensional vector b, s.t.: \{ Ax <= b \} for a d-dimensional
H-polytope with m facets.

For skinny hypercubes and product of simplices only H-representation is available. So for a skinny
hypercube run:

```
> PolyList = GenSkinnyCube(5)
```

This command will generate a 5-dimensional skinny hypercube.


                       ------------------------------------------------------




2. Sample From a Convex Polytope

You can use volesti to sample uniformly from a convex polytope. You have to use function sample_points().
The default method is coordinate directions hit-and-run. For example:

  a. To sample 1000 uniform points from a 10-dimensional cross polytope using Coordinate Directions
     Hit-and-Run run:

```
> PolyList = GenCross(10, 'H')
> sample = sample_points(A = PolyList$A, b = PolyList$b, N = 1000)
```

The output is \{ dxN \} matrix that containes column-wise the random points.
The default length for the random walk is \{ \floor{10 + 10/d} \}. If you want to give a different length
run:

```
> sample = sample_points(A = PolyList$A, b = PolyList$b, N = 1000, walk_length = 5)
```

  b. To sample 1000 uniform points from a 20-dimensional simplex using Random Directions Hit-and-Run run:
 
```
> PolyList = GenSimplex(20, 'H')
> sample = sample_points(A = PolyList$A, b = PolyList$b, N = 1000, coordinate = FALSE)
```

You can set the length of the HnR as before.

  c. To print the excecutional time use the flag `verbose`:

```
> PolyList = GenProdSimplex(5)
> sample = sample_points(A = PolyList$A, b = PolyList$b, N = 1000, verbose = TRUE)
```

                       ------------------------------------------------------
                               



3. Compute the volume of a convex polytope.

You can use volesti to compute the volume of a convex polytope. The default algorithm is SequenceOfBalls
and the default random walk algorithm is Coordinate directions HnR. For example:

  a. To compute a volume approximation of the 10-dimensional hypercube run:

```
> PolyList = GenCube(10, 'H')
> vol = volume(A = PolyList$A, b = PolyList$b)
```

To print all the computational steps and excecutional time use the flag verbose:

```
> vol = volume(A = PolyList$A, b = PolyList$b, verbose = TRUE)
```

  b. To use Random Directions Hit-and-Run or to change the length of the HnR run:

```
> vol = volume(A = PolyList$A, b = PolyList$b, walk_length = 20, coordinate = FALSE)
```


                                ~~~~~~~~~~~~~~~~~~~~~~~~~
                                ~~~~~~~~EXERCISES~~~~~~~~
                                ~~~~~~~~~~~~~~~~~~~~~~~~~

1. Compare Coordinate Directions Hit-and-Run with Random Directions Hit-and-run:
  
  a. Consider a constant number of sampled points (e.g. N=5000) and start with the 5-dimensional hypercube.
     Increase the dimension with a step (e.g. step=10) and compare the excecutional times. Do not forget
     to use the flag verbose!

  b. Run the same experiments as in (a) but using cross polytopes. Start with dimension 2 and use a smaller
     step, e.g. 2.



2. Test CDHR efficiency:
  
  a. Consider a constant number of sampled points (N=10000) and start with a 10-dimensional simplex.
     Increase the dimension with step=10. When CDHR seems to be inefficient?
 
  b. Consider a constant number of sampled points (N=10000) and start with a 2-dimensional cross polytope.
     Increase the dimension with step=2. When CDHR seems to be inefficient?
 
  c. Generate a 100-dimensional hypercube. Start with N=10000 points and increase the number of points with
     a step=10000. When CDHR seems to be inefficient?


3. Compute approximations of volumes:

  a. Generate a 10-dimensional simplex and approximate the volume using the default algorithm and random
     walk method. Increase the dimension with step=10. Do the same using RDHR. Compare the excecutional times.

  b. Do the same as in (a) but for cross polytopes. Start in dimension=2 and increase with step=5. 



4. Compare two samples.

Peacock test is a generalization, for 2d and 3d samples, of the Kolmogorov-Smirnov test which is a
non-parametric test that can used to compare two samples. The null hypothesis is that the two samples
are drawn from the same distribution and the test decides if we can reject or not that hypothesis.

Package `Peacock.test` extracts two main functions: peacock2(x,y) and peacock3(x,y). The first is for
2-dimensional samples and the second for 3-dimensional samples. In both cases `x` and `y` have to be
\{ Nxd \} matrices where d is the dimension and N the cardinality of the data set. While the return values
in both functions are getting smaller it is more possible the two samples to have been drawn from the
same distribution.

  a. Use the function sample_simplex() to sample N=100 uniform points from the 3-dimensional simplex. Then
     generate a 3-dimensional simplex and use function sample_points() to sample N=100 points using CDHR.
     Start with walk_length=1 and increase it with step=10. How the value of the Peacock test changes?

  b. Construct a 2d skinny simplex (triangle) and use function sample_simplex() to sample uniform points.
     Then do the same as in (a) with N=100 by passing skinny simplex in sample_points() funtion.

  c. How can we apply the same "uniformity test" on a 3d cross polytope or on a 3d skinny cube?

-------------------------------------------------------------------------------------------------------------



NOTES:

1. To sample for a d-dimensional simplex using sample_simplex run:
```
> sample1 = sample_simplex(dimension = d, N = numpoints)
```

2. To construct a 2d skinny simplex you could consider the vertices of the triangle and add them row-wise
in matrix V. Then you can run:
```
sample1 = sample_simplex(vertices = V, N = 100)
```
To sample using CDHR you have either to compute the H-representation or to give it to the function
sample_points() as a V-polytope. For example run:
```
sample2 = sample_points(V = V, N=100, walk_length = 1)
```

3. For the peacock test you have to give the transposed sample matrices you exctract from `volesti` functions.
   For example:
```
peacock3(t(sample1), t(sample2))
``` 

4. You can also see the R script `sampling-tutorial.R` in folder /R-proj/inst.

    ~----------------------------------------------------------------------------------------------~
    ~!!Remember that the documentation `volesti.pdf` in folder /R-proj/inst/doc is always useful!! ~
    ~----------------------------------------------------------------------------------------------~





